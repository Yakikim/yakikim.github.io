---
layout: mynote
tags: [notes, memo, op, professional, devops, oracle, week, microservices, apex, management, infrastructures] 
created: 2021-11-08 09:31
modified: 2021-11-08 09:31
type: Document
title:  שבוע אורקל From Monolith to Micro services 
---
Week Of: [[2021-11-07]]
[[2021-11-08]]


#  תזכיר בנושא  שבוע אורקל From Monolith to Micro services

[[home]]/[[Open University]]/[[Memos]]

## שיעור 1
מרצה ניר גאייר Nirg@codewizard.co.il 0548122310 
למה לעבור לענן? זה מושך כ"א. מי שיודע היום [[K8s]] - יש לו עבודה ל20 שנה.. 
[[transparency]] כלי מומלץ למונוליט
למה לעבוד בקונטיינרים? 
- כי אם אתה מפתח בזה, אתה אוטומטית חושב MS וזה דוחף אותך למבנה ממודל.
לא להוציא את הקוד שלך כמות שהוא. יש למדל ולחשוב מחדש.
צריך לפתח את המ.ס. 

מיקרו-סרוויסים
מ.ס. היא יחידה קטנה ואטונומית ועצמאית ככל הניתן ועצמאית בתוך הרשת (ארגונית או כללית)
(חברת רפאל עובדת עם [[K8S]] ושירותים **בתוך הארגון**)
הגדרה: היחידה הכי קטנה שיכולה לתת מקסימום שירותים.
הגדרה אפשרית: מ.ס. יחידת **ביזנס** שנותנת שירות.
הגדרה: ארכיטקטורה כללית שאפליקציות בה נבנות כיחידות קטנות האפשריות מבחינה העסקית.
כל שירות עומד בפני עצמו.
למה זה טוב?
- פיתוח מהיר יותר ומורכב פחות
- שדרוג מהיר יותר
- אם סרוויס אחד נפל לא נפל כל המערכת
- כל שירות יכול להיבנות בטכנולוגיה שונה כי בסוף זה HTTP בתקשורת ביניהם. אני לא תלוי טכנולוגיה
- קל לי לבצע דפלוי לכל יחידה בפני עצמה.
- קל לבצע Scaling
*  -  כלי [Istio](https://istio.io/latest/) שהוא מומלץ for Traffic Management 
חסרונות של MS
- מדברים בקושי אחד עם השני - תקשורת בין שירותים.
- נדרש לעשות את זה בצורה מאובטחת וזה לא קל.
- לאורך זמן אני מתחיל לקבל צווארי בקבוק בהיבט התשתית.
- יותר סרטיפיקטים וכתובות IP וכו' וצריך לנהל אותם
- מורכבות בריבוי שפות תכנות
- איך אני יודע מאיפה הגעתי וכו
- נדרש לנהל הרבה יותר דברים!!
- עולה יותר (רשיונות, ענן וכו) לעומת מונוליט

# שיעור 2 11-12:30
> לחקור יותר [[GraphQL]] 

שני צורות מימוש:
1. #REST
במדה ומשנים רק את המונוליט בלי לשנות את המבנה ל-MS
בעיות עם REST:
- בדרך כלל הוא רק סינכרוני וגורם לבעיות Latency וצווארי בקבוק 
- בעיות Versioning וכו
2. SUB/PUB ([[Kafka]]) במדה ואני רוצה להימנע מסינכרוניות:
- אסינכרוני במדת הצורך.
- קל להרים עוד תורים
- בדרך כלל FIFO
- טרייסאביליטי
- מאפשר לי LoadBalancing כולם מקבלים את אותו ההודעה וגם אני יכול לפזר את העומסים לשרתים הפנויים שלי. 
- ניתן לבודד את השירותים ולפשט את השגיאות. כלומר, אני יכול לדעת מה אני מחזיר (שגיאה 400 וכו)
- סקיילאביליות

### Database per service
מה עושים כאשר הפעולות מדורגות במספר DB? ואם נדרש לבצע Rollback?
מה קורה במקרה של נפילה וצריך להרים סנאפשוט. 
ריבוי DB = ריבוי משאבי ניהול?
איך אני יודע שהם מסונכרנים?
> חשוב לנהל את זה בצורה לוגית כך שכל DB יהיה Source of truth לתחום העסקי שלו.

איך מממשים?
ראשית מבודדים כל DB בפני עצמו. אם זה אותו DB אז מבודדים כל סכמה בנפרד.
אתגרים: Data consistency, Cross DB queries, Different DB Types
פתרונות:
Partition Tolerance: אני לא רוצה שאם אחד השירותים שלי נפל, שהכל יפול. 
איך גורמים לזה? [[RAFT]] - אלגוריתם שיודע לתת לי שרידות של מידע. לדוגמא: אם יש לי קוברנטיס עם שלשה נודים שאחד מהם הוא מאסטר והיתר לגיבוי וריקאברי. כך שאם המאסטר שלי נפל האלגוריתם יודע להרים לי את הנוד השני שישמש מעתה כמאסטר.
[[CQRS]] - Command Query Responsibility Segregation 
יש לי DB אחד שהוא גם לקריאה וגם לכתיבה, אבל אני מייצר DB אחרים שמשמשים לקריאה בלבד. ואותו ה-DB לא חייב להיות פיזי אלא יכול להיות גם רק שירות שיהיה כמו VIEW או MS אחר. העניין פה הוא הפרדה **לוגית** בין מישהו שמגיש לי את הנתונים (שהוא Source Of truth) לבין מי שכותב לי את המידע. 
העדכון של הנתונים נעשים גם אסינכרונית ואפילו פעם ביום - לפי הנחיצות.

החסרון פה הוא שאם הוא נכשל, אין לי מי שמציג - Point of failure.

> מה שאני מבין הוא, שכדאי לשאוף אולי למצב של Synchronization של שירותים ולרוץ על הטבלאות האלו עם Views בשכבת האפליקציה.
לחילופין, להקים שכבה שבה השירותים כולם נכתבים כ-data ומשם יבוצעו שליפות נתונים דרך שירותים ***מרכזים(summarizes)***


## ארוחת צהרים והפסקה
## שיעור 3  13:45 - 15:00
המשך CQRS
אם אני רוצה לבצע Rollback, הEvent Sourcinsg יסייע לי בלהבין מה קרה ומה צריך לאחזר.
לדוגמא: חשבון בנק. אם עשיתי הפקדה ומשיכה, אני אראה את הנתונים הסופיים רק ביום אחרי, אבל בינתיים אני אקח את הבקשה שלו ומפרק אותה לפעולות ושם אותם בתור(Queue) מישהו אחר (בקשה להפקדה) מאזין לתור הזה ומבצע פעולה אחרת במקומות אחרים במערכת וכשהנתונים נכתבו הוא מחזיר את האיבנט של האישור. זה שניהלתי את זה כאיבנטים זה משמעותי בגלל הסדר של הכניסה של הפעולות לתור של האיבנטים. 

ההבדל בין PUB/SUB לאיבנט הוא ששם משהו יכול להכנס לתור ואף אחד לא ימשוך אותו. כאן, יש חשיבות לכל אירוע והטיפול בו הוא כמכלול ולפי סדר הכניסה.

אנחנו עובדים עם [[Domain Event]] שבסוף מספק לי רצף פעולות מסודר וטרייסאבילי. כתוצאה מזה יכולים להיות מקורות שינוי רבים(או לא) אבל הוא יסדר לי אותם בצורה מסודרת ויבצע אותם בדומיין בחוקיות מסודרת.

> יש ללמוד על [Prometheus - Monitoring system & time series database](https://prometheus.io/) שמבצעת טרייסינג על האירועים במיקרו-שירותים.

מה ההבדל בין Event Sourcing לבין Event Driven? Event Sourcing הרעיון הוא שאני מייצר לוגינג של הפעולות, לעומת Event Sourcing

איך שירותים מתקשרים ביניהם? 
אפשר באמצעות REST API
אופציה נוספת RPC - פרוטוקול שיודע להעביר נתונים בסקיילים גבוהים מאד. לדוגמא, HTTP1 זה עובד ברמת שיגור ואז שיגור בדיקה על תוצאות הפעולה הראשונה. לעומת זאת HTTP2 זה שיגור מתמשך ותוצאה בלייב וזה גם האופן של הRPC.

אז איך מבצעים את זה, כל הבקשות, מגיעות לתור ששירות עליו מחלק את העומסים, יש כאלו שמבצעים חלוקת עומסים בצורה אוטונומית. לדוגמא, משרד כרטיסים שנתקלת בתעבורה יוצאת דופן לעתים נדירות. אז המערכת הזו יכולה לנהל את העומס ורק כשיש צורך בשרתים נוספים, היא תבצע באופן אוטומטי ואוטונומי סקיילינג. כנ"ל לגבי הורדת השרתים בסיום התקופה הבעייתית.

מהו איבנט?
כל מצב של שינוי באחד הStates של המערכת הוא Event.
איבנטים אמורים להיות אסינכרוניים.

## שיעור 4 ואחרון

[[Kafka]]
יש Broker ותחתיו יש Topic שזה מאחד תחתיו Partition
איך עושים Deployment לדברים? איך מנהלים סרטיפיקאתים במעבר בין סביבות?
האם צריך CI/CD לכל מיקרוסרביס? 
Sidecar Pattern - אם בא אלי מישהו מהארגון ומבקש להחליף את כל הסרביס שלי מ-HTTP ל-HTTPS זה פרוייקט גדול. אבל בK8S יש את זה שאם אני מתקין את המוצר הזה שראינו [[Istio]] שהוא מוצר MS מסוג Sidecar Pattern מייצר עוד POD שמטפל בכל העניין הזה של התקשורת ביניהם (במקום לנהל את זה בכל קונטיינר בנפרד).
[[12Factor App]] - [אתר אינטרנט](https://12factor.net/) שמרכז שנים עשר כללים שאני צריך להתייחס אליהם ולעבוד לפיהם כאשר אני בא לאפיין אפליקציה חדשה שמתפקדת כ Service או SaaS 

## סוף היום
לאחר שהציבור התפזר, המרצה הסביר למעוניינים על אלגוריתם ה: [[RAFT]] 
[The Secret Lives of Data](http://thesecretlivesofdata.com/)





#memo #op/memo
